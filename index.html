<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Comprimir PDF</title>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Cantarell:wght@400;700&display=swap');

  :root {
    /* Adwaita Light */
    --bg: #fafafa;
    --surface: #ffffff;
    --surface-alt: #f6f5f4;
    --border: #deddda;
    --border-strong: #c0bfbc;
    --text: #3d3846;
    --text-dim: #77767b;
    --accent: #1c71d8;
    --accent-hover: #1a5fb4;
    --accent-bg: #99c1f1;
    --success: #26a269;
    --success-bg: #8ff0a4;
    --warning: #e5a50a;
    --error: #c01c28;
    --error-bg: #f66151;
    --card-shadow: 0 1px 3px rgba(0,0,0,0.07), 0 1px 2px rgba(0,0,0,0.05);
    --card-shadow-hover: 0 3px 8px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.06);
    --radius: 12px;
    --radius-sm: 8px;
    --transition: 150ms ease;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #242424;
      --surface: #303030;
      --surface-alt: #383838;
      --border: #4a4a4a;
      --border-strong: #636363;
      --text: #f6f5f4;
      --text-dim: #9a9996;
      --accent: #62a0ea;
      --accent-hover: #99c1f1;
      --accent-bg: #1a5fb4;
      --success: #57e389;
      --success-bg: #26a269;
      --warning: #f8e45c;
      --error: #f66151;
      --error-bg: #a51d2d;
      --card-shadow: 0 1px 3px rgba(0,0,0,0.2), 0 1px 2px rgba(0,0,0,0.15);
      --card-shadow-hover: 0 3px 8px rgba(0,0,0,0.3), 0 1px 3px rgba(0,0,0,0.2);
    }
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Cantarell', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem 1rem;
  }

  .app {
    width: 100%;
    max-width: 640px;
  }

  .header {
    text-align: center;
    margin-bottom: 1.5rem;
  }
  .header h1 {
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 0.25rem;
  }
  .header p {
    color: var(--text-dim);
    font-size: 0.9rem;
  }

  .dropzone {
    border: 2px dashed var(--border-strong);
    border-radius: var(--radius);
    background: var(--surface);
    padding: 2.5rem 1.5rem;
    text-align: center;
    cursor: pointer;
    transition: border-color var(--transition), background var(--transition), box-shadow var(--transition);
    position: relative;
  }
  .dropzone:hover, .dropzone.dragover {
    border-color: var(--accent);
    background: color-mix(in srgb, var(--accent) 6%, var(--surface));
    box-shadow: var(--card-shadow-hover);
  }
  .dropzone input[type="file"] {
    position: absolute;
    inset: 0;
    opacity: 0;
    cursor: pointer;
  }
  .dropzone-icon {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    opacity: 0.6;
  }
  .dropzone-label {
    font-size: 0.95rem;
    color: var(--text-dim);
  }
  .dropzone-label strong {
    color: var(--accent);
  }

  .settings {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 1rem 1.25rem;
    margin-top: 1rem;
    box-shadow: var(--card-shadow);
  }
  .settings-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }
  .settings-row + .settings-row {
    margin-top: 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px solid var(--border);
  }
  .settings-label {
    font-size: 0.9rem;
  }
  .settings-label small {
    display: block;
    color: var(--text-dim);
    font-size: 0.8rem;
    margin-top: 2px;
  }
  .settings input[type="range"] {
    font-family: inherit;
    font-size: 0.85rem;
    accent-color: var(--accent);
  }
  .range-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  .range-group input[type="range"] {
    width: 120px;
  }
  .range-value {
    font-size: 0.85rem;
    font-variant-numeric: tabular-nums;
    min-width: 3ch;
    text-align: right;
    color: var(--text-dim);
  }

  .file-list {
    margin-top: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  .file-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    padding: 0.85rem 1rem;
    box-shadow: var(--card-shadow);
    animation: slideIn 200ms ease;
  }
  @keyframes slideIn {
    from { opacity: 0; transform: translateY(6px); }
    to   { opacity: 1; transform: translateY(0); }
  }
  .file-card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
  }
  .file-name {
    font-size: 0.9rem;
    font-weight: 700;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
  }
  .file-size {
    font-size: 0.8rem;
    color: var(--text-dim);
    white-space: nowrap;
  }
  .file-status {
    margin-top: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  .file-status-text {
    font-size: 0.8rem;
    color: var(--text-dim);
  }

  .progress-bar {
    flex: 1;
    height: 6px;
    background: var(--surface-alt);
    border-radius: 3px;
    overflow: hidden;
  }
  .progress-fill {
    height: 100%;
    background: var(--accent);
    border-radius: 3px;
    width: 0%;
    transition: width 120ms linear;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.75rem;
    font-weight: 700;
    padding: 0.15rem 0.5rem;
    border-radius: 999px;
  }
  .badge-success {
    background: color-mix(in srgb, var(--success) 15%, transparent);
    color: var(--success);
  }
  .badge-error {
    background: color-mix(in srgb, var(--error) 15%, transparent);
    color: var(--error);
  }
  .badge-reduction {
    background: color-mix(in srgb, var(--accent) 12%, transparent);
    color: var(--accent);
    font-variant-numeric: tabular-nums;
  }

  .btn-remove {
    background: none;
    border: none;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 1.1rem;
    line-height: 1;
    padding: 0.1rem 0.3rem;
    border-radius: 4px;
    transition: background var(--transition), color var(--transition);
  }
  .btn-remove:hover {
    background: color-mix(in srgb, var(--error) 12%, transparent);
    color: var(--error);
  }
  .btn-defaults {
    font-family: inherit;
    font-size: 0.8rem;
    font-weight: 700;
    background: none;
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-dim);
    padding: 0.3rem 0.7rem;
    cursor: pointer;
    transition: background var(--transition), color var(--transition), border-color var(--transition);
  }
  .btn-defaults:hover {
    background: var(--surface-alt);
    color: var(--text);
    border-color: var(--border-strong);
  }

  .actions {
    margin-top: 1.25rem;
    display: flex;
    gap: 0.75rem;
    justify-content: center;
    flex-wrap: wrap;
  }
  .btn {
    font-family: inherit;
    font-size: 0.9rem;
    font-weight: 700;
    border: none;
    border-radius: var(--radius-sm);
    padding: 0.65rem 1.5rem;
    cursor: pointer;
    transition: background var(--transition), opacity var(--transition), box-shadow var(--transition);
  }
  .btn:disabled {
    opacity: 0.45;
    cursor: not-allowed;
  }
  .btn-primary {
    background: var(--accent);
    color: #fff;
  }
  .btn-primary:hover:not(:disabled) {
    background: var(--accent-hover);
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  .btn-secondary {
    background: var(--surface-alt);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover:not(:disabled) {
    background: var(--border);
  }

  .footer {
    margin-top: 2rem;
    text-align: center;
    font-size: 0.78rem;
    color: var(--text-dim);
  }
  .footer a {
    color: var(--accent);
  }
  .footer code {
    background: var(--surface-alt);
    padding: 0.1rem 0.3rem;
    border-radius: 3px;
    font-size: 0.75rem;
  }

  .hidden { display: none !important; }
</style>
</head>
<body>

<div class="app">
  <header class="header">
    <h1>üìÑ Comprimir PDF</h1>
    <p>Recomprime im√°genes embebidas, preserva texto y vectores ‚Äî todo local</p>
  </header>

  <div class="dropzone" id="dropzone">
    <div class="dropzone-icon">üìÅ</div>
    <div class="dropzone-label">
      Arrastr√° archivos PDF ac√° o <strong>hac√© clic para elegir</strong>
    </div>
    <input type="file" id="fileInput" accept=".pdf,application/pdf" multiple>
  </div>

  <div class="settings">
    <div class="settings-row">
      <div class="settings-label">
        Resoluci√≥n m√°x. (DPI)
        <small>Im√°genes mayores a este DPI se reducen</small>
      </div>
      <div class="range-group">
        <input type="range" id="dpiRange" min="72" max="300" value="200" step="1">
        <span class="range-value" id="dpiValue">200</span>
      </div>
    </div>
    <div class="settings-row">
      <div class="settings-label">
        Calidad JPEG
        <small>0.1 = m√°xima compresi√≥n</small>
      </div>
      <div class="range-group">
        <input type="range" id="qualityRange" min="0.1" max="1.0" value="0.75" step="0.05">
        <span class="range-value" id="qualityValue">0.75</span>
      </div>
    </div>
    <div class="settings-row" style="justify-content: flex-end;">
      <button class="btn-defaults" id="btnDefaults" title="Restablecer valores por defecto">‚Ü∫ Defaults</button>
    </div>
  </div>

  <div class="file-list" id="fileList"></div>

  <div class="actions">
    <button class="btn btn-primary" id="btnCompress" disabled>Comprimir</button>
    <button class="btn btn-secondary hidden" id="btnDownloadAll">Descargar todo (.zip)</button>
    <button class="btn btn-secondary hidden" id="btnClear">Limpiar</button>
  </div>

  <footer class="footer">
    Procesamiento local con <a href="https://pdf-lib.js.org/" target="_blank">pdf-lib</a> +
    <a href="https://github.com/nicedoc/pako" target="_blank">pako</a>.
    Equivalente a <code>gs -dDownsampleColorImages -dColorImageResolution=200</code>.
  </footer>
</div>

<script type="module">
// ‚îÄ‚îÄ Imports ‚îÄ‚îÄ
const PDFLib = await import('https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/+esm');
const { PDFDocument, PDFRawStream, PDFName, PDFNumber, PDFArray } = PDFLib;

// pako for inflate (FlateDecode streams)
const pakoMod = await import('https://cdn.jsdelivr.net/npm/pako@2.1.0/+esm');
const pakoInflate = pakoMod.inflate || pakoMod.default?.inflate;

// JSZip (lazy)
let JSZip = null;
async function getJSZip() {
  if (!JSZip) {
    const mod = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm');
    JSZip = mod.default || mod;
  }
  return JSZip;
}

// ‚îÄ‚îÄ State ‚îÄ‚îÄ
const files = [];
let idCounter = 0;

// ‚îÄ‚îÄ DOM ‚îÄ‚îÄ
const dropzone       = document.getElementById('dropzone');
const fileInput      = document.getElementById('fileInput');
const fileListEl     = document.getElementById('fileList');
const btnCompress    = document.getElementById('btnCompress');
const btnDownloadAll = document.getElementById('btnDownloadAll');
const btnClear       = document.getElementById('btnClear');
const btnDefaults    = document.getElementById('btnDefaults');
const dpiRange       = document.getElementById('dpiRange');
const dpiValueEl     = document.getElementById('dpiValue');
const qualityRange   = document.getElementById('qualityRange');
const qualityValueEl = document.getElementById('qualityValue');

// ‚îÄ‚îÄ Settings ‚îÄ‚îÄ
dpiRange.addEventListener('input', () => dpiValueEl.textContent = dpiRange.value);
qualityRange.addEventListener('input', () => qualityValueEl.textContent = parseFloat(qualityRange.value).toFixed(2));

const DEFAULTS = { dpi: 200, quality: 0.75 };
btnDefaults.addEventListener('click', () => {
  dpiRange.value = DEFAULTS.dpi;
  dpiValueEl.textContent = DEFAULTS.dpi;
  qualityRange.value = DEFAULTS.quality;
  qualityValueEl.textContent = DEFAULTS.quality.toFixed(2);
});

// ‚îÄ‚îÄ File Input ‚îÄ‚îÄ
dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', e => {
  e.preventDefault();
  dropzone.classList.remove('dragover');
  addFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', () => { addFiles(fileInput.files); fileInput.value = ''; });

function addFiles(input) {
  for (const f of input) {
    if (f.type !== 'application/pdf' && !f.name.toLowerCase().endsWith('.pdf')) continue;
    files.push({
      id: ++idCounter, file: f, status: 'pending', progress: 0,
      resultBlob: null, resultSize: 0, error: null, imgStats: null
    });
  }
  render();
}

// ‚îÄ‚îÄ Render ‚îÄ‚îÄ
function render() {
  btnCompress.disabled = files.length === 0 || files.some(f => f.status === 'processing');
  btnDownloadAll.classList.toggle('hidden', files.filter(f => f.status === 'done').length < 2);
  btnClear.classList.toggle('hidden', files.length === 0);

  fileListEl.innerHTML = '';
  for (const f of files) {
    const card = document.createElement('div');
    card.className = 'file-card';

    let statusHTML = '';
    if (f.status === 'pending') {
      statusHTML = `<span class="file-status-text">En espera</span>`;
    } else if (f.status === 'processing') {
      statusHTML = `
        <div class="progress-bar"><div class="progress-fill" style="width:${f.progress}%"></div></div>
        <span class="file-status-text">${f.progress}%</span>`;
    } else if (f.status === 'done') {
      const reduction = ((1 - f.resultSize / f.file.size) * 100).toFixed(1);
      const imgInfo = f.imgStats
        ? ` ¬∑ ${f.imgStats.recompressed}/${f.imgStats.total} imgs recomprimidas`
        + (f.imgStats.skipped > 0 ? `, ${f.imgStats.skipped} sin cambio` : '')
        : '';
      statusHTML = `
        <span class="badge badge-success">‚úì Listo</span>
        <span class="badge badge-reduction">‚àí${reduction}%</span>
        <span class="file-size">${formatSize(f.resultSize)}${imgInfo}</span>`;
    } else if (f.status === 'error') {
      statusHTML = `<span class="badge badge-error">‚úó Error</span> <span class="file-status-text">${f.error}</span>`;
    }

    const canRemove = f.status !== 'processing';
    const canDownload = f.status === 'done';

    card.innerHTML = `
      <div class="file-card-header">
        <span class="file-name" title="${esc(f.file.name)}">${esc(f.file.name)}</span>
        <span class="file-size">${formatSize(f.file.size)}</span>
        ${canDownload ? `<button class="btn-remove" data-action="download" data-id="${f.id}" title="Descargar">‚¨á</button>` : ''}
        ${canRemove ? `<button class="btn-remove" data-action="remove" data-id="${f.id}" title="Quitar">‚úï</button>` : ''}
      </div>
      <div class="file-status">${statusHTML}</div>`;
    fileListEl.appendChild(card);
  }
}

fileListEl.addEventListener('click', e => {
  const btn = e.target.closest('[data-action]');
  if (!btn) return;
  const id = parseInt(btn.dataset.id);
  if (btn.dataset.action === 'remove') {
    const idx = files.findIndex(f => f.id === id);
    if (idx !== -1) files.splice(idx, 1);
    render();
  } else if (btn.dataset.action === 'download') {
    const f = files.find(f => f.id === id);
    if (f?.resultBlob) downloadBlob(f.resultBlob, f.file.name.replace(/\.pdf$/i, '_compressed.pdf'));
  }
});

btnClear.addEventListener('click', () => { files.length = 0; render(); });

// ‚îÄ‚îÄ Compress all ‚îÄ‚îÄ
btnCompress.addEventListener('click', async () => {
  const targetDPI = parseInt(dpiRange.value);
  const jpegQuality = parseFloat(qualityRange.value);

  for (const f of files) {
    if (f.status !== 'done') {
      f.status = 'processing'; f.progress = 0;
      f.error = null; f.resultBlob = null; f.imgStats = null;
    }
  }
  render();

  for (const f of files) {
    if (f.status !== 'processing') continue;
    try {
      const result = await compressPDF(f.file, targetDPI, jpegQuality, p => { f.progress = p; render(); });
      f.resultBlob = result.blob;
      f.resultSize = result.blob.size;
      f.imgStats = result.imgStats;
      f.status = 'done';
    } catch (err) {
      console.error(err);
      f.status = 'error';
      f.error = err.message || 'Error desconocido';
    }
    render();
  }
});

// ‚îÄ‚îÄ Download All ‚îÄ‚îÄ
btnDownloadAll.addEventListener('click', async () => {
  const ZipClass = await getJSZip();
  const zip = new ZipClass();
  for (const f of files) {
    if (f.status === 'done' && f.resultBlob)
      zip.file(f.file.name.replace(/\.pdf$/i, '_compressed.pdf'), f.resultBlob);
  }
  downloadBlob(await zip.generateAsync({ type: 'blob' }), 'pdfs_comprimidos.zip');
});


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CORE: Ghostscript-equivalent image recompression
//  - Iterates PDF internal objects
//  - Finds Image XObjects (the embedded images)
//  - Decodes ‚Üí renders to canvas ‚Üí recompresses as JPEG
//  - Replaces stream data in-place
//  - Text, fonts, vectors, annotations: UNTOUCHED
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function compressPDF(file, targetDPI, jpegQuality, onProgress) {
  const arrayBuf = await file.arrayBuffer();
  const pdfDoc = await PDFDocument.load(new Uint8Array(arrayBuf), {
    ignoreEncryption: true,
    updateMetadata: false,
  });

  // Collect all Image XObjects
  const imageObjects = [];
  for (const [ref, obj] of pdfDoc.context.enumerateIndirectObjects()) {
    if (!(obj instanceof PDFRawStream)) continue;
    const { dict } = obj;
    const subtype = dict.get(PDFName.of('Subtype'));
    if (!subtype || subtype.toString() !== '/Image') continue;

    // Skip image masks
    const imageMask = dict.get(PDFName.of('ImageMask'));
    if (imageMask && imageMask.toString() === 'true') continue;

    const w = getNumValue(dict, 'Width');
    const h = getNumValue(dict, 'Height');
    if (!w || !h || w < 4 || h < 4) continue;

    imageObjects.push({ ref, obj, dict, width: w, height: h });
  }

  const stats = { total: imageObjects.length, recompressed: 0, skipped: 0 };

  for (let i = 0; i < imageObjects.length; i++) {
    try {
      const replaced = await recompressImage(pdfDoc, imageObjects[i], targetDPI, jpegQuality);
      if (replaced) stats.recompressed++; else stats.skipped++;
    } catch (e) {
      console.warn(`Image ${i} skipped:`, e.message);
      stats.skipped++;
    }
    onProgress(Math.round(((i + 1) / Math.max(imageObjects.length, 1)) * 95));
    await yieldToUI();
  }

  onProgress(98);
  const pdfBytes = await pdfDoc.save();
  onProgress(100);

  return {
    blob: new Blob([pdfBytes], { type: 'application/pdf' }),
    imgStats: stats
  };
}


async function recompressImage(pdfDoc, imgInfo, targetDPI, jpegQuality) {
  const { obj, dict, width, height } = imgInfo;

  // --- Read filter ---
  const filterObj = dict.get(PDFName.of('Filter'));
  let filters = [];
  if (filterObj) {
    const fs = filterObj.toString();
    if (fs.startsWith('[')) {
      // Array of filters ‚Äî extract names
      filters = fs.replace(/[\[\]]/g, '').trim().split(/\s+/);
    } else {
      filters = [fs];
    }
  }

  const primaryFilter = filters[filters.length - 1] || ''; // last filter = outermost encoding

  // --- Decode raw bytes ---
  let pixelBytes;
  let isJPEG = false;

  if (primaryFilter.includes('DCTDecode')) {
    isJPEG = true;
    // Raw JPEG ‚Äî we'll decode via browser
  } else if (primaryFilter.includes('FlateDecode')) {
    try {
      pixelBytes = pakoInflate(new Uint8Array(obj.contents));
    } catch {
      throw new Error('Failed to inflate FlateDecode');
    }
    // Handle PNG predictor (common with FlateDecode)
    const dp = dict.get(PDFName.of('DecodeParms'));
    if (dp) {
      const predictor = getNumFromDict(dp, 'Predictor');
      if (predictor >= 10) {
        pixelBytes = undoPNGFilter(pixelBytes, width, height, dict);
      }
    }
  } else if (primaryFilter === '' || primaryFilter === '[]') {
    pixelBytes = new Uint8Array(obj.contents);
  } else {
    // JBIG2, JPX, CCITTFax ‚Äî not worth touching
    throw new Error(`Unsupported filter: ${primaryFilter}`);
  }

  // --- Color space & BPC ---
  const csObj = dict.get(PDFName.of('ColorSpace'));
  const csStr = csObj ? csObj.toString() : '/DeviceRGB';
  const bpc = getNumValue(dict, 'BitsPerComponent') || 8;

  let channels = 3; // default RGB
  if (csStr.includes('DeviceGray') || csStr.includes('CalGray')) channels = 1;
  else if (csStr.includes('DeviceCMYK')) channels = 4;

  // --- Render to canvas ---
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  if (isJPEG) {
    const blob = new Blob([obj.contents], { type: 'image/jpeg' });
    const bmp = await createImageBitmap(blob);
    canvas.width = bmp.width;
    canvas.height = bmp.height;
    ctx.drawImage(bmp, 0, 0);
    bmp.close();
  } else {
    canvas.width = width;
    canvas.height = height;
    const imgData = ctx.createImageData(width, height);
    const px = imgData.data;

    if (channels === 1 && bpc === 8) {
      for (let p = 0; p < width * height; p++) {
        const v = pixelBytes[p] || 0;
        px[p*4] = v; px[p*4+1] = v; px[p*4+2] = v; px[p*4+3] = 255;
      }
    } else if (channels === 3 && bpc === 8) {
      for (let p = 0; p < width * height; p++) {
        px[p*4]   = pixelBytes[p*3]   || 0;
        px[p*4+1] = pixelBytes[p*3+1] || 0;
        px[p*4+2] = pixelBytes[p*3+2] || 0;
        px[p*4+3] = 255;
      }
    } else if (channels === 4 && bpc === 8) {
      // CMYK ‚Üí RGB
      for (let p = 0; p < width * height; p++) {
        const c = pixelBytes[p*4]   / 255;
        const m = pixelBytes[p*4+1] / 255;
        const y = pixelBytes[p*4+2] / 255;
        const k = pixelBytes[p*4+3] / 255;
        px[p*4]   = Math.round(255 * (1-c) * (1-k));
        px[p*4+1] = Math.round(255 * (1-m) * (1-k));
        px[p*4+2] = Math.round(255 * (1-y) * (1-k));
        px[p*4+3] = 255;
      }
    } else if (bpc === 1 && channels === 1) {
      // 1-bit monochrome
      const rowBytes = Math.ceil(width / 8);
      for (let row = 0; row < height; row++) {
        for (let col = 0; col < width; col++) {
          const byteIdx = row * rowBytes + Math.floor(col / 8);
          const bitIdx = 7 - (col % 8);
          const bit = (pixelBytes[byteIdx] >> bitIdx) & 1;
          const v = bit ? 0 : 255;
          const p = row * width + col;
          px[p*4] = v; px[p*4+1] = v; px[p*4+2] = v; px[p*4+3] = 255;
        }
      }
    } else {
      throw new Error(`Unsupported format: ${channels}ch ${bpc}bpc`);
    }

    ctx.putImageData(imgData, 0, 0);
  }

  // --- Downsample (like gs -dColorImageResolution=200) ---
  const srcW = canvas.width;
  const srcH = canvas.height;

  // Estimate max pixel dimensions at target DPI for a generous page size (12√ó16 in)
  const maxW = targetDPI * 12;
  const maxH = targetDPI * 16;

  let outW = srcW, outH = srcH;
  if (srcW > maxW || srcH > maxH) {
    const scale = Math.min(maxW / srcW, maxH / srcH, 1);
    outW = Math.max(1, Math.round(srcW * scale));
    outH = Math.max(1, Math.round(srcH * scale));
  }

  const outCanvas = document.createElement('canvas');
  outCanvas.width = outW;
  outCanvas.height = outH;
  const outCtx = outCanvas.getContext('2d');
  outCtx.imageSmoothingEnabled = true;
  outCtx.imageSmoothingQuality = 'high';
  outCtx.drawImage(canvas, 0, 0, outW, outH);

  // --- Export JPEG ---
  const jpegBlob = await new Promise(r => outCanvas.toBlob(r, 'image/jpeg', jpegQuality));
  const jpegBytes = new Uint8Array(await jpegBlob.arrayBuffer());

  // Cleanup canvases
  canvas.width = 0; canvas.height = 0;
  outCanvas.width = 0; outCanvas.height = 0;

  // Only replace if smaller
  if (jpegBytes.length >= obj.contents.length) return false;

  // --- Replace stream in PDF ---
  obj.contents = jpegBytes;
  dict.set(PDFName.of('Filter'), PDFName.of('DCTDecode'));
  dict.set(PDFName.of('Width'), PDFNumber.of(outW));
  dict.set(PDFName.of('Height'), PDFNumber.of(outH));
  dict.set(PDFName.of('BitsPerComponent'), PDFNumber.of(8));
  dict.set(PDFName.of('ColorSpace'), PDFName.of('DeviceRGB'));
  dict.set(PDFName.of('Length'), PDFNumber.of(jpegBytes.length));
  dict.delete(PDFName.of('DecodeParms'));
  dict.delete(PDFName.of('SMask'));

  return true;
}


// ‚îÄ‚îÄ PNG Predictor undo (Sub/Up/Average/Paeth) ‚îÄ‚îÄ
function undoPNGFilter(data, width, height, dict) {
  const csObj = dict.get(PDFName.of('ColorSpace'));
  const csStr = csObj ? csObj.toString() : '/DeviceRGB';
  const bpc = getNumValue(dict, 'BitsPerComponent') || 8;
  let channels = 3;
  if (csStr.includes('DeviceGray') || csStr.includes('CalGray')) channels = 1;
  else if (csStr.includes('DeviceCMYK')) channels = 4;

  const bytesPerPixel = Math.max(1, Math.ceil(channels * bpc / 8));
  const rowBytes = Math.ceil(width * channels * bpc / 8);
  const out = new Uint8Array(height * rowBytes);

  let srcOffset = 0;
  for (let row = 0; row < height; row++) {
    const filterType = data[srcOffset++];
    const dstRow = row * rowBytes;
    const prevRow = (row - 1) * rowBytes;

    for (let i = 0; i < rowBytes; i++) {
      const raw = data[srcOffset++] || 0;
      const a = i >= bytesPerPixel ? out[dstRow + i - bytesPerPixel] : 0;
      const b = row > 0 ? out[prevRow + i] : 0;
      const c = (row > 0 && i >= bytesPerPixel) ? out[prevRow + i - bytesPerPixel] : 0;

      let val;
      switch (filterType) {
        case 0: val = raw; break;
        case 1: val = raw + a; break;
        case 2: val = raw + b; break;
        case 3: val = raw + Math.floor((a + b) / 2); break;
        case 4: val = raw + paethPredictor(a, b, c); break;
        default: val = raw;
      }
      out[dstRow + i] = val & 0xFF;
    }
  }
  return out;
}

function paethPredictor(a, b, c) {
  const p = a + b - c;
  const pa = Math.abs(p - a);
  const pb = Math.abs(p - b);
  const pc = Math.abs(p - c);
  if (pa <= pb && pa <= pc) return a;
  if (pb <= pc) return b;
  return c;
}


// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ
function getNumValue(dict, key) {
  const obj = dict.get(PDFName.of(key));
  if (!obj) return null;
  if (typeof obj.numberValue === 'function') return obj.numberValue();
  if (typeof obj.value === 'function') return obj.value();
  const n = parseInt(obj.toString());
  return isNaN(n) ? null : n;
}

function getNumFromDict(dictObj, key) {
  if (!dictObj || typeof dictObj.get !== 'function') return 0;
  return getNumValue(dictObj, key) || 0;
}

function yieldToUI() { return new Promise(r => setTimeout(r, 0)); }

function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
}

function esc(str) {
  const d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 5000);
}

render();
</script>

</body>
</html>
